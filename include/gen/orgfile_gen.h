//
// include/gen/orgfile_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/command_gen.h"
#include "include/gen/algo_gen.h"
//#pragma endinclude

// --- orgfile_FieldIdEnum

enum orgfile_FieldIdEnum {        // orgfile.FieldId.value
     orgfile_FieldId_value   = 0
};

enum { orgfile_FieldIdEnum_N = 1 };

namespace orgfile { struct FFilehash; }
namespace orgfile { struct trace; }
namespace orgfile { struct FDb; }
namespace orgfile { struct FFilename; }
namespace orgfile { struct FieldId; }
namespace orgfile { struct _db_filename_curs; }
namespace orgfile { struct _db_ind_filename_curs; }
namespace orgfile { struct _db_filehash_curs; }
namespace orgfile { struct _db_ind_filehash_curs; }
namespace orgfile { struct filehash_c_filename_curs; }
namespace orgfile {
    typedef algo::Smallstr40 FFilehashPkey;
}//pkey typedefs
namespace orgfile {
extern const char *orgfile_help;
extern const char *orgfile_syntax;
extern FDb _db;

// --- orgfile.trace
#pragma pack(push,1)
struct trace { // orgfile.trace
    trace();
};
#pragma pack(pop)

// print string representation of orgfile::trace to string LHS, no header -- cprint:orgfile.trace.String
void                 trace_Print(orgfile::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- orgfile.FDb
// create: orgfile.FDb._db (Global)
struct FDb { // orgfile.FDb
    command::orgfile       cmdline;                      //
    orgfile::FFilename*    filename_lary[32];            // level array
    i32                    filename_n;                   // number of elements in array
    orgfile::FFilename**   ind_filename_buckets_elems;   // pointer to bucket array
    i32                    ind_filename_buckets_n;       // number of elements in bucket array
    i32                    ind_filename_n;               // number of elements in the hash table
    orgfile::FFilehash*    filehash_lary[32];            // level array
    i32                    filehash_n;                   // number of elements in array
    orgfile::FFilehash**   ind_filehash_buckets_elems;   // pointer to bucket array
    i32                    ind_filehash_buckets_n;       // number of elements in bucket array
    i32                    ind_filehash_n;               // number of elements in the hash table
    orgfile::trace         trace;                        //
};

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
orgfile::FFilename&  filename_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
orgfile::FFilename*  filename_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                filename_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 filename_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
orgfile::FFilename*  filename_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
orgfile::FFilename*  filename_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  filename_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 filename_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 filename_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
orgfile::FFilename&  filename_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 filename_XrefMaybe(orgfile::FFilename &row);

// Return true if hash is empty
bool                 ind_filename_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
orgfile::FFilename*  ind_filename_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
orgfile::FFilename&  ind_filename_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_filename_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_filename_InsertMaybe(orgfile::FFilename& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_filename_Remove(orgfile::FFilename& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_filename_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
orgfile::FFilehash&  filehash_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
orgfile::FFilehash*  filehash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                filehash_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 filehash_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
orgfile::FFilehash*  filehash_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
orgfile::FFilehash*  filehash_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  filehash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 filehash_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 filehash_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
orgfile::FFilehash&  filehash_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 filehash_XrefMaybe(orgfile::FFilehash &row);

// Return true if hash is empty
bool                 ind_filehash_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
orgfile::FFilehash*  ind_filehash_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
orgfile::FFilehash&  ind_filehash_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
orgfile::FFilehash&  ind_filehash_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_filehash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_filehash_InsertMaybe(orgfile::FFilehash& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_filehash_Remove(orgfile::FFilehash& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_filehash_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
void                 _db_filename_curs_Reset(_db_filename_curs &curs, orgfile::FDb &parent);
// cursor points to valid item
bool                 _db_filename_curs_ValidQ(_db_filename_curs &curs);
// proceed to next item
void                 _db_filename_curs_Next(_db_filename_curs &curs);
// item access
orgfile::FFilename&  _db_filename_curs_Access(_db_filename_curs &curs);
// cursor points to valid item
void                 _db_filehash_curs_Reset(_db_filehash_curs &curs, orgfile::FDb &parent);
// cursor points to valid item
bool                 _db_filehash_curs_ValidQ(_db_filehash_curs &curs);
// proceed to next item
void                 _db_filehash_curs_Next(_db_filehash_curs &curs);
// item access
orgfile::FFilehash&  _db_filehash_curs_Access(_db_filehash_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- orgfile.FFilehash
// create: orgfile.FDb.filehash (Lary)
// global access: ind_filehash (Thash)
// access: orgfile.FFilename.p_filehash (Upptr)
struct FFilehash { // orgfile.FFilehash
    orgfile::FFilehash*    ind_filehash_next;   // hash next
    algo::Smallstr40       filehash;            //
    orgfile::FFilename**   c_filename_elems;    // array of pointers
    u32                    c_filename_n;        // array of pointers
    u32                    c_filename_max;      // capacity of allocated array
private:
    friend orgfile::FFilehash&  filehash_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend orgfile::FFilehash*  filehash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 filehash_RemoveAll() __attribute__((nothrow));
    friend void                 filehash_RemoveLast() __attribute__((nothrow));
    FFilehash();
    ~FFilehash();
    FFilehash(const FFilehash&){ /*disallow copy constructor */}
    void operator =(const FFilehash&){ /*disallow direct assignment */}
};

// Return true if index is empty
bool                 c_filename_EmptyQ(orgfile::FFilehash& filehash) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
orgfile::FFilename*  c_filename_Find(orgfile::FFilehash& filehash, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<orgfile::FFilename*> c_filename_Getary(orgfile::FFilehash& filehash) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_filename_Insert(orgfile::FFilehash& filehash, orgfile::FFilename& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_filename_InsertMaybe(orgfile::FFilehash& filehash, orgfile::FFilename& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_filename_N(const orgfile::FFilehash& filehash) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_filename_Remove(orgfile::FFilehash& filehash, orgfile::FFilename& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_filename_RemoveAll(orgfile::FFilehash& filehash) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_filename_Reserve(orgfile::FFilehash& filehash, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFilehash_Init(orgfile::FFilehash& filehash);
void                 filehash_c_filename_curs_Reset(filehash_c_filename_curs &curs, orgfile::FFilehash &parent);
// cursor points to valid item
bool                 filehash_c_filename_curs_ValidQ(filehash_c_filename_curs &curs);
// proceed to next item
void                 filehash_c_filename_curs_Next(filehash_c_filename_curs &curs);
// item access
orgfile::FFilename&  filehash_c_filename_curs_Access(filehash_c_filename_curs &curs);
void                 FFilehash_Uninit(orgfile::FFilehash& filehash) __attribute__((nothrow));

// --- orgfile.FFilename
// create: orgfile.FDb.filename (Lary)
// global access: ind_filename (Thash)
// access: orgfile.FFilehash.c_filename (Ptrary)
struct FFilename { // orgfile.FFilename
    orgfile::FFilename*   ind_filename_next;            // hash next
    algo::cstring         filename;                     //
    algo::Smallstr40      filehash;                     //
    orgfile::FFilehash*   p_filehash;                   // reference to parent row
    bool                  deleted;                      //   false
    bool                  filehash_c_filename_in_ary;   //   false  membership flag
private:
    friend orgfile::FFilename&  filename_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend orgfile::FFilename*  filename_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 filename_RemoveAll() __attribute__((nothrow));
    friend void                 filename_RemoveLast() __attribute__((nothrow));
    FFilename();
    ~FFilename();
    FFilename(const FFilename&){ /*disallow copy constructor */}
    void operator =(const FFilename&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FFilename_Init(orgfile::FFilename& filename);
void                 FFilename_Uninit(orgfile::FFilename& filename) __attribute__((nothrow));

// --- orgfile.FieldId
#pragma pack(push,1)
struct FieldId { // orgfile.FieldId: Field read helper
    i32   value;   //   -1
    inline operator orgfile_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(orgfile_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
orgfile_FieldIdEnum  value_GetEnum(const orgfile::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(orgfile::FieldId& parent, orgfile_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const orgfile::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const orgfile::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(orgfile::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(orgfile::FieldId& parent, algo::strptr rhs, orgfile_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(orgfile::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of orgfile::FieldId from an ascii string.
// The format of the string is the format of the orgfile::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(orgfile::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(orgfile::FieldId& parent);
// print string representation of orgfile::FieldId to string LHS, no header -- cprint:orgfile.FieldId.String
void                 FieldId_Print(orgfile::FieldId & row, algo::cstring &str) __attribute__((nothrow));

struct _db_filename_curs {// cursor
    typedef orgfile::FFilename ChildType;
    orgfile::FDb *parent;
    i64 index;
    _db_filename_curs(){ parent=NULL; index=0; }
};


struct _db_filehash_curs {// cursor
    typedef orgfile::FFilehash ChildType;
    orgfile::FDb *parent;
    i64 index;
    _db_filehash_curs(){ parent=NULL; index=0; }
};


struct filehash_c_filename_curs {// cursor
    typedef orgfile::FFilename ChildType;
    orgfile::FFilename** elems;
    u32 n_elems;
    u32 index;
    filehash_c_filename_curs() { elems=NULL; n_elems=0; index=0; }
};

int                  main(int argc, char **argv);
} // end namespace orgfile
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const orgfile::trace &row);// cfmt:orgfile.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const orgfile::FieldId &row);// cfmt:orgfile.FieldId.String
}
